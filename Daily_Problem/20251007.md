# [1488. 避免洪水泛滥](https://leetcode.cn/problems/avoid-flood-in-the-city/)

## 解题思路

1. 本题难点在于当$rains[i] = 0$的时候, 应该选择那个湖泊抽干
   1. 在$rains[i] = 0$的时候没有一个湖泊有水, 这个时候随便选择一个湖泊抽干
   2. 在$rains[i] = 0$的时候存在一个湖泊有水, 这个时候应该选择未来会再次下雨$(rains[i] > 0)$且时间距离今天最近的那个湖泊抽干



## 参考代码

+ 时间复杂度$O(n \log n)$


```cpp
class Solution {
public:
    vector<int> avoidFlood(vector<int>& rains) {
        int n = rains.size();
        map<int, set<int>> mp;
        for (int i = 0; i < n; ++i) {
            mp[rains[i]].insert(i);
        }

        priority_queue<int, vector<int>, greater<int>> pq;
        set<int> fill;
        vector<int> ans;
        for (int i = 0; i < n; ++i) {
            if (rains[i] == 0) {
                if (!pq.empty()) {
                    int next_i = pq.top();
                    pq.pop();

                    fill.erase(rains[next_i]);
                    ans.push_back(rains[next_i]);
                } else {
                    ans.push_back(1);
                }
            } else if (fill.count(rains[i])) {
                return {};
            } else {
                ans.push_back(-1);
                fill.insert(rains[i]);
                mp[rains[i]].erase(i);

                if (!mp[rains[i]].empty()) {
                    pq.push(*mp[rains[i]].begin());
                }
            }
        }
        return ans;
    }
};
```

