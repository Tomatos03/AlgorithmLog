# [2919. 使数组变美的最小增量运算数](https://leetcode.cn/problems/minimum-increment-operations-to-make-array-beautiful/)

## 解题思路

1. 原问题让$[0, n - 1]$数组变美的最小增量运算可以分解为让$[1, n - 1]$的子数组变美的最小增量运算(这个分解适用于$nums[i] \ge k$的情况)加上让$nums[0] \ge k$ 所需要的最小运算次数
1. 当分解出来的子数组长度小于$3$的时候直接返回0


## 参考代码

+ 时间复杂度$O(n)$

### 递归


```cpp
class Solution {
public:
    vector<int> nums;
    int k;
    int n;
    vector<long long> memo;

    long long dfs(int x) {
        if (x >= n - 2) {
            return 0;
        }

        if (memo[x] != LLONG_MAX) {
            return memo[x];
        }

        for (int i = 0; i < 3; ++i) {
            memo[x] = min(max(k - nums[x + i], 0) + dfs(x + i + 1), memo[x]);
        }
        return memo[x];
    }

    long long minIncrementOperations(vector<int>& nums, int k) {
        this->nums = nums;
        this->k = k;
        this->n = nums.size();
        this->memo = vector<long long>(n, LLONG_MAX);
        return dfs(0);
    }
};

```

### 递推

```cpp
using i64 = long long;
class Solution {
public:
    long long minIncrementOperations(vector<int>& nums, int k) {
        int n = nums.size();
        vector<i64> f(n + 1, LLONG_MAX);
        nums.insert(nums.begin(), 0);
        f[0] = f[1] = f[2] = 0;

        for (int i = 3; i <= n; ++i) {
            for (int j = i; j > i - 3; --j) {
                int op_num = max(0, k - nums[j]);
                f[i] = min(f[i], f[j - 1] + op_num);
            }
        }
        return f[n];
    }
};

```

