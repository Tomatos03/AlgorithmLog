# [186. 施咒的最大总伤害](https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/)

## 解题思路

1. 排序并不影响最终的结果, 先将原数组从小到大进行排序, 统计数的出现次数并去除重复的数
2. 让$f[i]$表示$[1, i]$的咒语能够得到的最大总伤害, 原问题存在一些子问题:
   1. 如果最后一个咒语不使用, 那么$f[i] = f[i - 1]$
   2. 如果最后一个 咒语确定使用, 那么$f[i] = f[j], j < i \and power[i] - power[j] > 2$


## 参考代码

+ 时间复杂度$O(n \log n)$


```cpp
using i64 = long long;
class Solution {
public:
    long long maximumTotalDamage(vector<int>& power) {
        map<int, int> cnt;
        for (int &v : power) {
            cnt[v]++;
        }

        int n = cnt.size();
        vector<int> vec;
        for (auto [v, _] : cnt) {
            vec.push_back(v);
        }

        vector<i64> f(n);
        f[0] = 1LL * cnt[vec[0]] * vec[0];
        for (int i = 1; i < n; ++i) {
            i64 w = cnt[1LL * vec[i]] * vec[i];

            f[i] = max(f[i - 1], w);

            for (int j = i - 1; j >= max(i - 3, 0); --j) {
                if (vec[i] - vec[j] > 2) {
                    f[i] = max(f[i], f[j] + w);
                    break;
                }
            }
        }
        return f[n - 1];
    }
};

```
