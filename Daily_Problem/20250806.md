# [808. 分汤](https://leetcode.cn/problems/soup-servings/)

## 解题思路

1. 主要到原问题能够拆分成一些子问题: $f(a, b) = 0.25 \times(f(a - 100, b), f(a - 75, b - 25), f(a - 50, b - 50), f(a - 25, b - 75))$
2. 子问题中存在大量重复考虑记录计算过的值, 减少重复计算
3. 输入数据$n \leq 10^9$, 数据量非常大,  注意到每轮减少的量$\frac{i}{25} = 1, 2, 3, 4$, 其中$i$表示每一轮的减少两. 所有的可能只有四种结果, 输入数据量减少到 $n / 25 $
4. 尽管数据量减少了, 但是仍然很大无法直接处理. 本地只要求答案精度在$10^{-5}$之内: 

$$
对于每次操作有: \\
A 的期望减少量为: E[ΔA]=0.25×(4+3+2+1)=2.5 \\
B 的期望减少量为: E[ΔB]=0.25×(0+1+2+3)=1.5 \\
A 的消耗速度比 B 快（2.5 > 1.5），因此随着 n 增大，A 先分配完的概率趋近于 1 \\
当 n 较大时，P(n,n)≈P(n−2.5,n−1.5)≈...≈P(n−2.5^i,n−1.5^i)≈1 \\
$$

5. 尝试计算部分数, 找到精度满足$10^{-5}$的$n$, 经过计算$n = 4475$

```cpp
using i32 = int;
using pii = pair<i32, i32>;

class Solution {
    map<pii, double> mp;
    const i32 d[4][2] = {
        {4, 0},
        {3, 1},
        {2, 2},
        {1, 3}
    };

public:
    double cal(i32 a, i32 b) {
        if (a <= 0 && b <= 0)
            return 0.5;
        if (a <= 0)
            return 1.0;
        if (b <= 0) 
            return 0.0;
        if (mp.count({a, b})) 
            return mp[{a, b}];

        double res = 0.0;
        for (int i = 0; i < 4; ++i) 
            res += 0.25 * cal(a - d[i][0], b - d[i][1]);

        mp[{a, b}] = res;
        return res;
    }

    double soupServings(int n) {
        if (n > 4800) return 1.0; 
        int N = (n + 24) / 25;    
        return cal(N, N);
    }
};
```