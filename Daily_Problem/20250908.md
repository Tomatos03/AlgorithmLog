# [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

## 解题思路

1. 考虑先确定容器的一个端点(即枚举容器的右端点或左端点)
2. 这里枚举容器的有端点, 对于一个确定的端点$i$, 只需要找到满足$j < i \and height[j] \geq height[i]$的点$j$, 如果存在多个满足条件的点, 选择距离$i$最远的那个点$j$
3. 根据$2$的分析只需要在顺序遍历数组时维护一个递增序列$que$, 枚举到点$i$时, 在$que$之中进行二分查找, 找到满足条件(第2点分析的条件)的第一个点, 此时的容量为$height[i] * (i - j)$


## 参考代码

+ 时间复杂度$O(n\log{n})$


```cpp
using i32 = int;
using i64 = long long;
using pii = pair<int, int>;
using pll = pair<i64, i64>;
using tdii = tuple<double, int, int>;
const int mod = 1000000007, mod0 = 998244353;
class Solution {
public:
    int f(vector<int> &height) {
        int ans = 0, n = height.size();
        vector<int> que;
        que.push_back(0);
        for (int i = 1; i < n; ++i) {
            int pos = lower_bound(que.begin(), que.end(), i, [&](int &x,const int &y){
                return height[x] < height[y];
            }) - que.begin();

            if (pos != que.size()) {
                int w = i - que[pos];
                ans = max(ans, w * height[i]);
            }

            if (height[i] > height[que.back()])
                que.push_back(i);
        }
        return ans;
    }
    int maxArea(vector<int>& height) {
        int ans = f(height);
        reverse(height.begin(), height.end());
        return max(ans, f(height));
    }
};

```
