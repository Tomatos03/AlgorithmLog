# [417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

## 解题思路

1. 从矩阵的边界出发, 利用$BFS$类似染色, 渲染与相邻的单元格, 渲染的条件是相邻单元格的高度高于当前单元格


## 参考代码

+ 时间复杂度$O(nm)$


```cpp
int dx[] = {0, 0, -1, 1}, dy[] = {1, -1, 0, 0};
class Solution {
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        vector<vector<int>> &h = heights;
        int n = h.size(), m = h[0].size();

        vector<vector<bool>> vis[2];
        vector<vector<int>> f(n, vector<int>(m, 0));
        vis[0] = vector<vector<bool>>(n, vector<bool>(m, false));
        vis[1] = vector<vector<bool>>(n, vector<bool>(m, false));

        queue<vector<int>> que;
        for (int i = 0; i < n; ++i) {
            que.push({i, 0, 0});
            que.push({i, m - 1, 1});
        }
        for (int j = 0; j < m; ++j) {
            que.push({0, j, 0});
            que.push({n - 1, j, 1});
        }

        while (!que.empty()) {
            vector<int> tmp = que.front();
            que.pop();
            int x = tmp[0], y = tmp[1], k = tmp[2];
            if (vis[k][x][y]) {
                continue;
            }
            vis[k][x][y] = true;
            ++f[x][y];

            for (int i = 0; i < 4; ++i) {
                int x0 = x + dx[i], y0 = y + dy[i];
                if (x0 < 0 || y0 < 0 || x0 >= n || y0 >= m || vis[k][x0][y0]) {
                    continue;
                }
                if (h[x0][y0] >= h[x][y]) {
                    que.push({x0, y0, k});
                }
            }
        }

        vector<vector<int>> ans;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (f[i][j] == 2) {
                    ans.push_back({i, j});
                }
            }
        }
        return ans;
    }
};

```

