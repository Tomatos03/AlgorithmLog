# [2787. 将一个数字表示成幂的和的方案数](https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/)

## 解题思路

1. 所用整数互不相同, 考虑顺序处理这些数(防止排列的产生)

2. 存在一个递推式$f(n, start) = f(n - j^x, j + 1), start \leq j \and j^x <= n$, $f(n, start)$表示使用大于等于$start$的数组成$n$的方案数
3. 第2点的递推式总是考虑有选择的情况, 进一步分类可以得到:
    + 没有使用$start$, $f(n, start) = f(n, start + 1)$
    + 使用了$start$, $f(n, start) = f(n - start^x, start + 1)$




+ 写法一

```cpp
using i32 = int;
using i64 = long long;
const int mod = 1000000007;

class Solution {
public:
    int numberOfWays(int n, int x) {
        // 预处理最大可用的base
        int max_base = 1;
        while (pow(max_base, x) <= n) ++max_base;
        --max_base;

        vector<vector<i64>> dp(n+1, vector<i64>(max_base+2, 0));
        // base case
        for (int start = 1; start <= max_base+1; ++start) dp[0][start] = 1;

        for (int sum = 1; sum <= n; ++sum) {
            for (int start = max_base; start >= 1; --start) {
                i64 p = 1;
                for (int i = 0; i < x; ++i) p *= start;
                dp[sum][start] = dp[sum][start+1];
                if (sum >= p) {
                    dp[sum][start] = (dp[sum][start] + dp[sum-p][start+1]) % mod;
                }
            }
        }
        return dp[n][1];
    }
};

```

+ 写法二

```cpp
using i32 = int;
using i64 = long long;
using pii = pair<int, int>;
using pll = pair<i64, i64>;
const int mod = 1000000007, mod0 = 998244353;

vector<vector<i64>> f = vector<vector<i64>>(301, vector<i64>(301, -1));

i32 pow0(i32 x, i32 y) {
    i32 res = 1;
    for (int i = 1; i <= y; ++i)
        res *= x;
    return res;
}

class Solution {
    i32 x;

    i32 dfs(i32 n, i32 start) {
        if (n <= 0)
            return n == 0;

        if (f[n][start] != -1)
            return f[n][start];

        f[n][start] = 0;
        i32 j = start, p_v = pow0(j, x);
        while (p_v <= n) {
            f[n][start] = (f[n][start] + dfs(n - p_v, j + 1)) % mod;

            ++j;
            p_v = pow0(j, x);
        }
        return f[n][start];
    }

public:
    int numberOfWays(int n, int x) {
        this->x = x;

        for (int i = 0; i <= 300; ++i) {
            for (int j = 0; j <= 300; ++j) {
                f[i][j] = -1;
            }
        }

        return dfs(n, 1);
    }
};

```

