# [621. 任务调度器](https://leetcode.cn/problems/task-scheduler/)

## 解题思路

让$max(cnt)$表示某个大写字母在$tasks$最大出现次数, $cnt(max(cnt))$表示最大出现次数的数量

1. 考虑一个构造方式: 找到任务之中出现次数最多的那个任务, 按照要求先填充这个任务, 可以得到$mx(cnt)$个间隔, 每一个间隔有$n + 1$个位置, 其中出现次数最多的字母占了一个, 剩下$n$个空闲的位置填充当前间隔没有出现过的字母. 下图每一行表示一个间隔:![fig2](https://assets.leetcode-cn.com/solution-static/621/2.png)
2. 构造方式存在两种情况:
   1. 一个间隔填充完互不相同的字母之后, 字母数量$\leq n + 1$, 此时答案为: $(mx(cnt) - 1)(n + 1) + cnt(max(cnt))$  
   2. 一个间隔填充完互不相同的字母之后, 字母数量$\geq n + 1$, 在上图之中的表示是大于$n + 1$列, 这个时候, 会出现一些空闲的间隔, 上图中第一行和最后一行都存在空闲的位置, 对于最后一行的空闲位置可以直接不管, 非最后一行的直接将后面的非空闲位置前移, 此时仍然满足两个相同任务间隔大于$n$ 


##  参考代码


```cpp
using i32 = int;
using i64 = long long;
using pii = pair<int, int>;
using pll = pair<i64, i64>;
using tdii = tuple<double, int, int>;
const int mod = 1000000007, mod0 = 998244353;
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        vector<int> cnt(26);
        for (char c : tasks) {
            ++cnt[c - 'A'];
        }
        int mx = 0, mx_cnt = 0;
        for (int i = 0; i < 26; ++i) {
            if (cnt[i] > mx) {
                mx = cnt[i];
                mx_cnt = 1;
            } else if (cnt[i] == mx) {
                ++mx_cnt;
            }
        }

        return max((n + 1) * (mx - 1) + mx_cnt, int(tasks.size()));
    }
};

```
