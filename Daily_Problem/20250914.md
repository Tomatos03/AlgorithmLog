# [1194C - From S To T ](https://codeforces.com/problemset/problem/1194/C)

## 解题思路

1. $s$字符串能够通过操作变成$t$字符串, 其中一个必要的条件是$s$是$t$的子序列, 如果不能够满足$s$是$t$的子序列必然不可能通过操作变为$t$
1. 在$t$删除子序列$s$剩下的字符在$p$之中都能够提供(字符存在, 且数量足够), 那么就一定能够通过操作让$s$变为$t$, 反之则不能

## 参考代码

+ 时间复杂度$O(len(s))$, 其中$len(s)$表示字符串的长度


```cpp
#include <bits/stdc++.h>
using namespace std;

#define endl '\n'
#define rep(i, a, b) for (int i = a; i <= b; ++i)
#define erp(i, a, b) for (int i = a; i >= b; --i)

using i32 = int;
using i64 = long long;
using pii = pair<int, int>;
using pll = pair<i64, i64>;

const int mod = 1000000007, mod0 = 998244353;

void solve() {
    string s, t, p;
    cin >> s >> t >> p;
    vector<int> cnt(26);
    for (char c : t) {
        cnt[c - 'a']++;
    }

    int n = s.size(), m = t.size();
    int i = 0, j = 0;
    while (j < m) {
        if (i < n && t[j] == s[i]) {
            --cnt[s[i] - 'a'];
            ++i;
        }
        ++j;
    }
    if (i != n) {
        cout << "NO" << endl;
        return;
    }
    for (char c : p) {
        --cnt[c - 'a'];
    }

    bool ok = true;
    for (int k = 0; k < 26; ++k) {
        ok &= cnt[k] <= 0;
    }
    cout << (ok ? "YES" : "NO") << endl;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t;
    cin >> t;
    while (t-- > 0)
        solve();
    return 0;
}

```
