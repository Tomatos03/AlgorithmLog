# [2411. 按位或最大的最小子数组长度](https://leetcode.cn/problems/smallest-subarrays-with-maximum-bitwise-or/)

## 解题思路

1. 如果输入数据量很小可以得到一个$O(n^2)$的解法: 双重循环, 外层循环固定左端点$l$, 里层循环遍历有端点$r$
2. 观察方法$1$可以得到一个启发, 在遍历数组的时候我们可以发现最多只有31次与操作能够让原有的数变大
	+ 对于$2$可以预处理出与左端点对应的数$nums[l]$进行与操作之后数变大的点那里
	+ 或假设当前$i$为最终的右端点, 初始化 $j = i - 1$, 只要能够满足$nusm[j] | nums[j + 1] = nums[j](nums[j]能够变大)$就不断的向左扩展$j$

```cpp
using i32 = int;
using pis = pair<i32, string>;

class Solution {
public:
    vector<int> smallestSubarrays(vector<int>& nums) {
        i32 n = nums.size();
        vector<i32> ans(n, 1);
        for (i32 i = 1; i < n; ++i) {
            i32 j = i - 1;
            while (j >= 0 && (nums[j] | nums[i]) != nums[j]) {
                nums[j] |= nums[i];
                ans[j] = i - j + 1;
                --j;
            }
        }
        return ans;
    }
};
```