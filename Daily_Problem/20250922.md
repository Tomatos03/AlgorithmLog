# [3005. 最大频率元素计数](https://leetcode.cn/problems/count-elements-with-maximum-frequency/)

## 解题思路

1. 找到最大的出现频数
2. 统计有多少个这样的频数

参考代码

+ 时间复杂度$O(n)$


```cpp
class Solution {
public:
    int maxFrequencyElements(vector<int>& nums) {
        int n = nums.size(), mx = 0, cnt = 0;
        vector<int> b(101);
        for (int &v : nums) {
            b[v]++;
            if (b[v] > mx) {
                mx = b[v];
                cnt = b[v];
            } else if (b[v] == mx) {
                cnt += b[v];
            }
        }
        return cnt;
    }
};
```



# [B. Yet Another Crosses Problem](https://codeforces.com/problemset/problem/1194/B)

## 解题思路

1. 统计每一行每一列有多少个$.$
2. 遍历整个矩阵, 对于一个特定的格子$(i, j)$, 最小操作次数为$col[j] + row[i] - (s[i][j] == '.')$, 其中$col[i]$表示第$j$列$.$的总数, $row[i]$表示第$i$行$.$的总数

参考代码

+ 时间复杂度$O(nm)$


```cpp
#include <bits/stdc++.h>
using namespace std;

#define endl '\n'
#define rep(i, a, b) for (int i = a; i <= b; ++i)
#define erp(i, a, b) for (int i = a; i >= b; --i)

using i64 = long long;
using i32 = int;
using pii = pair<int, int>;
using pll = pair<i64, i64>;

const int mod = 1000000007, mod0 = 998244353;

void solve() {
    int n, m;
    cin >> n >> m;

    string s[n];
    rep (i, 0, n - 1)
        cin >> s[i];

    vector<int> total_row(n), total_col(m);
    rep (i, 0, n - 1) {
        rep (j, 0, m - 1) {
            int w = s[i][j] == '.';
            total_col[j] += w;
            total_row[i] += w;
        }
    }

    int ans = INT_MAX;
    rep (i, 0, n - 1) {
        rep (j, 0, m - 1) {
            ans = min(ans, total_col[j] + total_row[i] - (s[i][j] == '.'));
        }
    }

    cout << ans << endl;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t;
    cin >> t;
    while (t-- > 0)
        solve();
    return 0;
}
```