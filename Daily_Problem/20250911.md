# [16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)

## 解题思路

1. 排序并不影响最终的结果, 所以先将数组进行排序

2. 如果确定了两个数$x$ 和 $y$, 那么此时问题可以转换找到距离$z = target - (x + y)$最近的数, 想要找到这样的数可以用二分查找)(原数组已排序)

   

   **算法细节补充**:

   + 在枚举第二个数的时候不需要从0开始, 而是直接从上一个确定的数的位置$i$下一个位置开始, 即从位置$j = i + 1$开始
   + 进行二分查找时的查找范围是$[j + 1, n)$


## 参考代码

+ 时间复杂度$O(n^2\log{n})$


```cpp
using i32 = int;
using i64 = long long;
using pii = pair<int, int>;
using pll = pair<i64, i64>;
using tdii = tuple<double, int, int>;
const int mod = 1000000007, mod0 = 998244353;
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        sort(nums.begin(), nums.end());

        int n = nums.size(), ans = INT_MAX / 2;
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                int v = target - (nums[i] + nums[j]);
                int pos0 = lower_bound(nums.begin() + j + 1, nums.end(), v) - nums.begin();
                if (pos0 != n) {
                    int sum = nums[i] + nums[j] + nums[pos0];
                    if (abs(sum - target) < abs(ans - target))
                        ans = sum;
                }

                if (pos0 > j + 1) {
                    int sum = nums[i] + nums[j] + nums[pos0 - 1];
                    if (abs(sum - target) < abs(ans - target))
                        ans = sum;
                }
            }
        }
        return ans;
    }
};

```
