# [778. 水位上升的泳池中游泳](https://leetcode.cn/problems/swim-in-rising-water/)

## 解题思路

1. 原问题从$(0, 0) \rightarrow (n - 1, n - 1)$需要的最少时间, 经过一次相邻单元格的移动可以拆分为$(0, 1) \rightarrow (n - 1, n - 1)$和$(1, 0) \rightarrow (n - 1, n - 1)$需要的最少时间的最小值
2. 经过$1$的分析考虑使用$BFS$来解决这个问题, 用$memo$数组记录从$(0, 0) \rightarrow (i, j)$ 所需要的最少时间, 当重复经过某个单元格的时, 如果当前到这个重复单元格所需要的时间大于$memo$数组记录的时间就放弃这个单元的遍历


## 参考代码

+ 时间复杂度$O(n^2t)$


```cpp
using i64 = long long;
using tiii = tuple<int, int, int>;

int dx[] = {0, 0, -1, 1}, dy[] = {1, -1, 0,0};
class Solution {
public:
    int swimInWater(vector<vector<int>>& grid) {
        vector<vector<int>> &g = grid;
        int n = g.size();

        vector<vector<int>> memo(n, vector<int>(n, INT_MAX));
        queue<tiii> que;
        que.push({0, 0, g[0][0]});

        while (!que.empty()) {
            auto [x, y, t] = que.front();
            que.pop();

            if (memo[x][y] <= t) {
                continue;
            }
            memo[x][y] = t;

            for (int i = 0; i < 4; ++i) {
                int x0 = dx[i] + x, y0 = dy[i] + y;
                if (x0 < 0 || y0 < 0 || x0 >= n || y0 >= n) {
                    continue;
                }

                que.push({x0, y0, max(t, g[x0][y0])});
            }
        }
        return memo[n - 1][n - 1];
    }
};

```

