# [120. 三角形最小路径和](https://leetcode.cn/problems/triangle/)

## 解题思路

1. 原问题: 从第$(i, j)$按照规则走到三角形最底部的最小路径和, 能够拆分为从$(i + 1, j)$和 $(i + 1, j + 1)$按照规则走到三角形最底部的最小路径和

##  参考代码

### 递归实现


```cpp
class Solution {
    int n;
    const int inf = INT_MIN / 2;
    vector<vector<int>> memo;
    int dfs(int k, int pos, vector<vector<int>> &t) {
        if (k == n) {
            return 0;
        }
        int &w = memo[k][pos];
        if (w != inf) {
            return w;
        }

        w = t[k][pos] + min(dfs(k + 1, pos, t), dfs(k + 1, pos + 1, t));
        return w;
    }

public:
    int minimumTotal(vector<vector<int>>& triangle) {
        this->n = triangle.size();
        memo = vector<vector<int>>(n, vector<int>(n, inf));
        return dfs(0, 0, triangle);
    }
};

```

### 递推实现

从上到下的最小路径可以转换为从下到上的最小路径

```cpp
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        vector<vector<int>> &t = triangle;
        int n = t.size();
        vector<vector<int>> f(n + 2, vector<int>(n + 2));
        for (int i = n; i >= 1; --i) {
            for (int j = 1; j <= i; ++j) {
                f[i][j] = min(f[i + 1][j + 1], f[i + 1][j]) + t[i - 1][j - 1];
            }
        }

        return f[1][1];
    }
};

```

