# [166. 分数到小数](https://leetcode.cn/problems/fraction-to-recurring-decimal/)

## 解题思路

1. 输入的两个数既可能是正数也可能是负数, 为了方便计算, 将输入的两个数都取绝对值, 取绝对值之前需要先判断最终运算的符号(输入两数同号即正, 异号即负), 还需要INT_MIN取绝对值会溢出的问题(先类型转换在取绝对值)
1. 输入两数的运算结果有两种情况**小数**或**整数**, 对于是**整数**的情况可以通过$numerator \% denominator$ 是否为0来判断
1. 运算结果是小数的情况又细分为两种**无限循环小数**或**有限循环小数**, 对于有限循环小数的情况很容易处理, 这里主要讲**无限循环小数**的情况怎么处理: 对于无限循环小数, 每次进行除法运算得到的余数$r$如果出现了两次, 那么说明已经进入了小数的第二个周期循环, 因为每次进行运算时的被除数是$r' \times 10$, 这里$r'$表示上一轮运算后的余数. (上述情况存在一个特殊情况 : 小数第一位的运算$r' = numrator$, 这一次运算得到的余数在下一次再次出现可能还没有进入小数循环的第二个周期, 参考: $numerator = 1, denominator = 6$, 这种情况的处理参考下面的代码)


## 参考代码

+ 时间复杂度$O(n)$


```cpp
using i64 = long long;
class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        string sign = 1LL * numerator * denominator >= 0 ? "" : "-";

        i64 num = abs(1LL * numerator), deno = abs(1LL * denominator);
        i64 r = num % deno;
        if (r == 0) {
            return sign + to_string(num / deno);
        }

        string head = to_string(num / deno);
        map<int, i64> vis;
        string tail = "";
        int i = 0;
        while (r != 0) {
            r *= 10;
            if (vis.count(r)) {
                string non_loop = tail.substr(0, vis[r]);
                string loop = tail.substr(vis[r]);
                return sign + head + "." + non_loop + "(" + loop + ")";
            }

            vis[r] = i;
            tail += to_string(r / deno);
            r %= deno;
            ++i;
        }

        return sign + head + '.' + tail;
    }
};

```
