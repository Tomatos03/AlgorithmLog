# [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

## 解题思路

1. 对于一条向下的路径中的子路径(不一定要以根节点为起点), 可以转换为以根节点为起点的两条路径的差
2. 由$1$得出一个式子$sum_i - sum_j = target$其中$sum_i$表示当前节点到根节点$i$的路径和并且即节点$j$所在层数小于$i$(越往下越大),  对这个式子变形得: $sum_i = target - sum_j$, 由这个式子可以知道遍历到$i$节点的时候统计之前遍历过程之中路径和的出现次数, 利用$HashMap$能够很好的解决这个问题

```cpp
using i64 = long long;
using i32 = int;
class Solution {
    i32 ans = 0;
    i32 target_sum = 0;

    void dfs(TreeNode *node, i64 cur_sum, map<i64, i32>& mp) {
        i32 v = node->val;
        cur_sum += v;
        i64 need_sum = cur_sum - target_sum;

        if (mp.count(need_sum))
            ans += mp[need_sum];

        mp[cur_sum]++;

        if (node->left != nullptr)
            dfs(node->left, cur_sum, mp);
        if (node->right != nullptr)
            dfs(node->right, cur_sum, mp);

        mp[cur_sum]--;
        if (mp[cur_sum] == 0)
            mp.erase(cur_sum);
    }

public:
    int pathSum(TreeNode* root, int targetSum) {
        if (root == nullptr)
            return 0;

        map<i64, i32> mp;
        mp[0]++;

        target_sum = targetSum;

        dfs(root, 0, mp);
        return ans;
    }
};

```