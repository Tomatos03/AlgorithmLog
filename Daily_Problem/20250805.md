# [581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)

## 解题思路

1. 最终子数组为有序数组, 比较最终数组和原来的数组, 可以得到部分公共前缀和后缀
1. 排序原来的数组, 需要的最短的子数组即为排序后的数组长度减去与原来数组的公共前缀和后缀

```cpp
using i32 = int;
using i64 = long long;
class Solution {
public:
    int findUnsortedSubarray(vector<int>& nums) {
        vector<i32> arr = nums;
        sort(nums.begin(), nums.end());
        i32 n = nums.size(), ans = 0;
        i32 l = 0, r = n - 1;
        while (l < n && nums[l] == arr[l])
            ++l;
        while (r >= 0 && nums[r] == arr[r])
            --r;
        return max(r - l + 1, 0);
    }
};

```