# [976. 三角形的最大周长](https://leetcode.cn/problems/largest-perimeter-triangle/)

## 解题思路

1. 排序不影响最后的结果, 将原数组$nums$从小到大排序
2. 枚举三角形三条边中的最长边
3. 当确定了最长边$nums[i]$之后, 贪心的选择$nums[i - 1]$, $nums[i - 2]$作为另外两条边, 如果满足三角形的构成条件$nums[i - 1] + nums[i - 2] > nums[i]$, 那么当前的三角形就是包含$nums[i]$这条边的三角形中周长最大的那个

### 贪心正确性证明

假设最优解选择的三条边为$nums[i], nums[j], nums[k], i < j < k$,  让$c$表示三条边中的最长边, 由于原数组已经从小到大排序, 所以$c = nums[k]$. 对于另外两条边, 存在两种情况:

1. $nums[i] = nums[k - 2], nums[j] = nums[k - 1]$, 这种情况与上述贪心策略得到的结果一致,
2. $nums[i] \neq nusm[i - 2] \or nums[i] \neq nums[i - 1]$, 此时如果还能够满足三角形的构成条件, 那么总是可以将$nums[i]$替换成$nums[k - 2]$, $nums[j]$替换成$nums[k - 1]$ ,  因为$nums[i] + nums[j] > nums[k]$, 必然有$nums[k - 1] + nums[k  - 2] > nums[i] + nums[j] > nums[k]$


## 参考代码

+ 时间复杂度$O(n)$


```java
import static java.lang.Math.*;

class Solution {
    public int largestPerimeter(int[] nums) {
        int n = nums.length;
        Arrays.sort(nums);
        for (int i = n - 1; i >= 2; --i) {
            int v = nums[i - 1] + nums[i - 2];
            if (v > nums[i])
                return v + nums[i];
        }
        return 0;
    }
}
```
