# [2044. 统计按位或能得到最大值的子集数目](https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/)

## 解题思路

1. 注意到选择一个子集之后, 将子集的数全部或运算得到最大的或值$max\_or$之后, 在与数组之中的其他数进行或运算不会有任何贡献, 故将给定数组$nums$的所有数进行或运算必然能够得到$max\_or$
2. 知道$max\_or$之后考虑直接暴力递归枚举(输入数据较小), 时间复杂度$O(n2^n)$

```cpp
using i32 = int;
using pis = pair<i32, string>;
class Solution {
    i32 mx_or = 0;
    i32 n;
    i32 ans;

    void dfs(vector<i32>& nums, vector<i32>& selected, int k) {
        if (k == n) {
            i32 cur_or = 0;
            for (int &v : selected)
                cur_or |= v;

            ans += cur_or == mx_or;
            return;
        }

        selected.push_back(nums[k]);
        dfs(nums, selected, k + 1);
        selected.pop_back();

        dfs(nums, selected, k + 1);;
    }

public:
    int countMaxOrSubsets(vector<int>& nums) {
        n = nums.size();

        for (int &v : nums)
            mx_or |= v;

        vector<i32> selected;
        dfs(nums, selected, 0);
        return ans;
    }
};

```