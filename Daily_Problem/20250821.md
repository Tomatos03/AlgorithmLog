# [1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/)

## 解题思路

1. 思考得到最优解的所有情况, 发现只有3种情况:
   1. 删除一个$0$, 然后两个都是$1$的子数组拼接成一个新的全是$1$的子数组
   2. 删除一个全是$1$的子数组左端或右端的$0$
   3. 给定数组全是$1$, 此时删除一个$1$
2. 预处理两个数组$suf[i] 和 pre[i]$
   + $pre[i]$表示从$i$这个位置开始向左延伸能够得到的连续且值都是$1$的子数组的最长长度
   + $suf[i]$表示从$i$这个位置开始向右延伸能够得到的连续且值都是$1$的子数组的最长长度

3. 对于$nums[i] == 0$的位置, 能够得到的局部最优解为$pre[i - 1] + suf[i + 1]$

4. 当给定数组$nums$全是$1$的时候答案为$n - 1$, 其中$n = len(nums)$

```cpp
using i32 = int;
using i64 = long long;
using pii = pair<int, int>;
using pll = pair<i64, i64>;
const int mod = 1000000007, mod0 = 998244353;
class Solution {
public:
    int longestSubarray(vector<int>& nums) {
        int n = nums.size(), ans = 0;

        vector<int> pre(n), suf(n);
        pre[0] = nums[0];
        suf[n - 1] = nums[n - 1];

        for (int i = 1; i < n; ++i) {
            if (nums[i] == 1)
                pre[i] = pre[i - 1] + 1;
        }

        for (int i = n - 2; i >= 0; --i) {
            if (nums[i] == 1)
                suf[i] = suf[i + 1] + 1;
        }
        
        for (int i = 0; i < n; ++i) {
            if (nums[i] == 1) 
                continue;

            int cur_v = 0;
            if (i - 1 >= 0)
                cur_v += pre[i - 1];
            if (i + 1 < n)
                cur_v += suf[i + 1];
            ans = max(ans, cur_v);
        }

        if (ans == 0 && nums[0] == 1)
            ans = n - 1;
        return ans;
    }
};

```

