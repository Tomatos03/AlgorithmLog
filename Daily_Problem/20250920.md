# [3508. 设计路由器](https://leetcode.cn/problems/implement-router/)

## 解题思路

1. 利用一个$queue<vector<int>>$ 和 $set<vector<int>>$ 存储每一个数据包, 可以模拟数据包的$FIFO$, 以及在$O(1)$时间内判断是否存在重复的数据包
1. 利用$map<int, deque<pii>>$以$destination$为依据分组, 题目给定数据包的$timestamp$总是递增的, 所以$map[destination]$总是有序的

##  参考代码


```cpp
using pii = pair<int, int>;
class Router {
public:
    int mx_n;
    queue<vector<int>> que;
    set<vector<int>> st;
    map<int, deque<pii>> mp;
    Router(int memoryLimit) {
        this->mx_n = memoryLimit;
    }

    bool addPacket(int source, int destination, int timestamp) {
        vector<int> data = {source, destination, timestamp};
        if (st.count(data)) {
            return false;
        }
        if (que.size() == mx_n) {
            vector<int> pre_data = que.front();
            que.pop();
            st.erase(pre_data);
            mp[pre_data[1]].pop_front();
        }

        st.insert(data);
        que.push(data);
        mp[destination].push_back({timestamp, source});
        return true;
    }

    vector<int> forwardPacket() {
        if (que.size() == 0) {
            return {};
        }

        vector<int> data = que.front();
        que.pop();

        st.erase(data);
        mp[data[1]].pop_front();
        return data;
    }

    int getCount(int destination, int startTime, int endTime) {
        const deque<pii> &due = mp[destination];
        int l = lower_bound(due.begin(), due.end(), startTime, [](const pii& a, int val) { return a.first < val; }) - due.begin();
        int r = upper_bound(due.begin(), due.end(), endTime, [](const int val, const pii& a) { return val < a.first; }) - due.begin();
        return r - l;
    }
};

```
