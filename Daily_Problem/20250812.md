# [C. Minimize Distance](https://codeforces.com/problemset/problem/1585/C)

## 解题思路

1. 排序并不影响最终的结果, 排序给定的数组
2. 数组中的正数和负数需要分类处理, 每一次选择的坐标序列只能够全部是正数, 或者负数, 如果既有负数又有正数, 总是可以分为两个坐标序列, 这样的拆分不改变移动距离且$k$可能比原来更大
3. 按顺序选择正数(负数)坐标序列, 总是更优的一种选法, 如果乱序选择(等价于顺序选择, 再发生一些交换), 总是会让移动距离变大
4. 由于最后一次派送不需要返回坐标原点,  从大到小,  每次挑选$k$个数(不足$k$个数时全部选择) ,  这样的做法总是最优的
5. 对于$4$的分析, 如果给定数组既有正数又有负数需要特殊处理

```cpp
#include <bits/stdc++.h>
using namespace std;

#define endl '\n'
#define rep(i, a, b) for (int i = a; i <= b; ++i)
#define erp(i, a, b) for (int i = a; i >= b; --i)

using i64 = long long;
using i32 = int;
using pii = pair<int, int>;
using pll = pair<i64, i64>;

const int mod = 1000000007, mod0 = 998244353;

i64 f(vector<i32>& arr, i32 k) {
    sort(arr.begin(), arr.end());

    i32 n = arr.size();
    if (n == 0)
        return 0;
    i64 cnt = arr[n - 1];
    i32 i = n - 1 - k;

    while (i >= 0) {
        cnt += 1LL * arr[i] * 2;
        i -= k;
    }
    return cnt;
}

void solve() {
    int n, k;
    cin >> n >> k;

    vector<i32> a, b;
    rep (i, 1, n) {
        i32 x;
        cin >> x;

        if (x >= 0)
            a.push_back(x);
        else 
            b.push_back(-x);
    }

    i64 ans = f(a, k) + f(b, k);
    if (a.size() != 0 && b.size() != 0)
        ans += min(a[a.size() - 1], b[b.size() - 1]);

    cout << ans << endl;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    int t;
    cin >> t;
    while (t-- > 0)
        solve();
    return 0;
}
```

