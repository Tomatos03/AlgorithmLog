# [2561. 重排水果](https://leetcode.cn/problems/rearranging-fruits/)

## 解题思路

1. 每一个数出现的次数必须为偶数, 否则不可能通过重排使两个数组相等
2. 可以通过使用最小值进行交换两次来交换想要交换的两个数
3. 去除两个数组之中都有的数之后, 剩下的数必然成对(可重复出现, 例如数字为2的对重复在同一个数组中出现多次)出现在两个数组的其中一个
4. 总是使用最小的数去交换另一个数组中较大的数

```cpp
using i32 = int;
using i64 = long long;
using pii = pair<int, int>;

class Solution {
public:
    long long minCost(vector<int>& basket1, vector<int>& basket2) {
        map<i32, i32> cnt0, cnt1;
        for (int &v: basket1)
            cnt0[v]++;
        for (int &v: basket2)
            cnt1[v]++;

        i32 mi = min(cnt0.begin()->first, cnt1.begin()->first);

        map<i32, i32> need;
        for (auto[v, num] : cnt0)
            need[v] += num;

        for (auto[v, num] : cnt1)
            need[v] += num;

        for (auto[v, num] : need) {
            if (num % 2 != 0)
                return -1;

            if (cnt0.count(v) && cnt1.count(v)) {
                i32 min_v = min(cnt1[v], cnt0[v]);
                cnt1[v] -= min_v;
                cnt0[v] -= min_v;
                if (cnt0[v] == 0)
                    cnt0.erase(v);

                if (cnt1[v] == 0)
                    cnt1.erase(v);
            }
        }
        vector<pii> a0, a1;
        for (auto[v, num] : cnt0)
            a0.push_back({v, num / 2});

        for (auto[v, num] : cnt1)
            a1.push_back({v, num / 2});

        sort(a0.begin(), a0.end());
        sort(a1.begin(), a1.end(), greater<pii>());
        i64 ans = 0;
        i32 n0 = a0.size(), n1 = a1.size();
        i32 i = 0, j = 0;
        while (i < n0 && j < n1) {
            i32 min_num = min(a0[i].second, a1[j].second);
            ans += 1LL * min(2 * mi, min(a0[i].first, a1[j].first)) * min_num;
            a0[i].second -= min_num;
            a1[j].second -= min_num;
            i += a0[i].second == 0;
            j += a1[j].second == 0;
        }
        return ans;
    }
};

```